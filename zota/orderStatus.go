package zota

import (
	"crypto/sha256"
	"fmt"
	"io"
	"net/http"
)

type ZotaOrderStatusBody struct {
	MerchantId      string `json:"merchantID"`
	OrderId         string `json:"orderID"`
	MerchantOrderID string `json:"merchantOrderID"`
	Timestamp       int64  `json:"timestamp"`
	Signature       string `json:"signature"`
}

// GenSignature generates the signature required for the Zota
// Order Status request and returns it.
// 
// Every request must be signed by the merchant in order to
// be successfully authenticated by Zotapay servers. The signature
// parameter of an Order Status Request must be generated by hashing
// a string of concatenated parameters using SHA-256 in the exact following order:
// 
// MerchantID + merchantOrderID + orderID + timestamp + MerchantSecretKey
func (zosb *ZotaOrderStatusBody) GenSignature(secretKey string) string {
	signatureStr := fmt.Sprintf(
		"%s%s%s%d%s",
		zosb.MerchantId,
		zosb.MerchantOrderID,
		zosb.OrderId,
		zosb.Timestamp,
		secretKey,
	)

	signature := fmt.Sprintf("%x", sha256.Sum256([]byte(signatureStr)))

	fmt.Printf("String to sign: %s\n", signatureStr)
	fmt.Printf("Signature: %s\n", signature)

	return signature
}

func pollOrderStatus(zosb *ZotaOrderStatusBody) {
	url := fmt.Sprintf(
		"https://api.zotapay-stage.com/api/v1/query/order-status/?merchantID=%s&orderID=%s&merchantOrderID=%s&timestamp=%d&signature=%s",
		zosb.MerchantId,
		zosb.OrderId,
		zosb.MerchantOrderID,
		zosb.Timestamp,
		zosb.Signature,
	)

	fmt.Printf("url: %s\n", url)
	fmt.Printf("zosb: %v\n", zosb)

	response, err := http.Get(url)
	if err != nil {
		panic(err)
	}

	defer response.Body.Close()

	fmt.Printf("status: %v\n", response.Status)
	fmt.Printf("status_code: %v\n", response.StatusCode)

	respBody, err := io.ReadAll(response.Body)
	if err != nil {
		panic(err)
	}

	fmt.Println("Raw response body: ", string(respBody))
}
